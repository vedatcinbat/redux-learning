-- Redux Notes --
-> Redux is a predictable state container to JavaScript apps
-> It helps you write applications that behave consistently, run in different 
environments, and are easy to test
-> Redux centralizes your application's state and logic, enabling powerful capabilities
like undo/redo, state persistence, and more

* Core Concepts of Redux
-> Single Source of Truth
--> The state of your whole application is stored in an object tree within a single store
--> This means there's only one state container (the store) for your entire application

-> State is Read-Only
--> The only way to change the state is to "emit an action", an object describing what happend
--> This ensures that no component can directly modify the state, which helps in maintainin
consistency

-> Changes are Made with Pure Functions
--> To specify how state tree is transformed by actions, you write pure reducers
--> A reducer is a pure function that takes the previous state and an action, and returns 
the next state

* Key Elements of Redux
1. Store
-> The store is the central container for the state in a Redux application. It holds the 
entire state tree of your application
-> There is only one store in a Redux application

2. Actions
-> Actions are plan Javascript objects that describe what happended in your application
-> Every action must have a "type" property that indicates the type of action being performed
-> The "type" should typically be defined as a string constant

const INCREMENT = 'INCREMENT';

const incrementAction = {
    type: INCREMENT
}

3. Reducers
-> Reducers are pure functions that take the current state and an action as arguments
and return a new state
-> They specify how to state changes in response to an action

const initialState = {value: 0};

function counterReducer(state = initialState, action) {
    switch(action.type) {
        case "INCREMENT":
            return {value: state.value + 1};
        case "DECREMENT":
            return {value: state.value - 1};
        default:
            return state;
    }
}

4. Dispatch
-> The "dispatch" function is used to send actions to the store. This is the only way to 
trigger a state change

store.dispatch(incrementAction);

5. Selectors
-> Selectors are functions that extract, derive, or compute specific pieces of data from the 
Redux state

const selectValue = state => state.value

6.Middleware
-> Middleware provides a way to extend Redux with custom functionality
-> It sits between the dispatching of an action and the moment it reaches the reducers
-> Common use cases include handling asynchronous action like API calls and logging
-> Example middleware: redux-thunk | redux-saga

When to Use Redux
Redux is particularly useful in the following scenarios:

Complex State Logic:

When the state logic is complex and involves many interactions across different parts of the application.
Predictability:

When you need predictable state management with clear rules on how state can be changed.
Debugging:

When you need powerful debugging capabilities, such as time-travel debugging, where you can go back and forth through the history of actions and state changes.
State Sharing:

When you need to share state across many components or deeply nested components.



-- Setting Up Project ------------------------------------
> npx create-react-app redux-ts-example --template typescript
> cd redux-ts-example

> npm install redux react-redux @reduxjs/toolkit

--- Project Structure ---
redux-ts-example/
├── src/
│   ├── store/
│   │   ├── actions.ts
│   │   ├── reducer.ts
│   │   ├── store.ts
│   │   ├── types.ts
│   ├── App.tsx
│   ├── Counter.tsx
│   ├── index.tsx
│   ├── react-app-env.d.ts
│   ├── setupTests.ts
│   ├── index.css
│   ├── App.css
│   ├── App.test.tsx
│   ├── logo.svg
├── package.json
├── tsconfig.json





------------------------------------------------------------------------



### Udemy Course: Ultimate Redux Course ##############################################
* What is Redux ?
-> Redux is a "state management" library for JavaScript applications
-> In other words, redux is used to manage data or state of "complex JavaScript applications"
-> You can you Redux with React, Angular, Vue, JavaScript
-> Centralize application's state
-> Data-flow transparent
-> Easily debug applications
-> Preserve the page state


* When we need Redux ?
-> Comples User interfaces in terms of data like facebook, amazon
-> Data flow is complex

---> When we dont use Redux
-> Small or medium size of applications
-> Simple UI & static data


* Setting up developmnet Environment
-> Webpack: is the bundler for bundle our JavaScript code in one file and then link with our browser
-> In simple words, we can write our JavaScript code in multiple files with using webpack


* What is Functional Programming ?
-> is one of the type of programming paradigms
-> Programming paradigms are the "methods" or we can say a set of rules to structure our code and to solve a problem
-> Procedural | Logical | Functional | Object-Oriented Programming

function greeting() {
    return function() {
        return 'Good Morning';
    }
}

let anFunction = greeting();
let message = anFunction();

console.log(message);

//let message = greeting;

/* function printMessage(anFunction) {
    console.log(anFunction());
}

printMessage(message); */

* What is Pure Functions ?
Pure function is a function which always give same output if we give it the same input

* How Redux Works ?
- Actions: What to do
- Reducers: How to do 
- Store: Keep data in single place


* Building Our First Application With Redux: Todo App
1. Designing the store
2. List our actions (What to do)
3. Create reducer function (How to do)
4. Create redux store


1. Designing the store
[
    {
        id: 1,
        task: "Design store",
        completed: false
    }
]


{
    tasks: [
        {
            id: 1,
            task: "Design Store",
            completed: false
        }, {...}, {...}
    ],
    employees: [
        {...},
        {...},
        {...},
    ]
}
-> We have 2 slices: Tasks | Employees 
-> Two reducer for each of them: TaskReducer | EmployeeReducer


2. Listing all Actions
-> ADD_TASK
-> REMOVE_TASK
-> TASK_COMPLETED

Action = What to do 

const addTaskAction = {
    type: "ADD_TASK",
    task: "This is new task!"
}

const remoevTaskAction = {
    type = "REMOVE_TASK",
    id: 1
}


{
    type: "ADD_TASK",
    payload: {
        task: "This is new task!"
    }
}


* Folder Structure
<src>
 <store>
  - store.js
  - action.js
  - reducer.js
  - actionTypes.js


--> 
<src>
 <store>
  - store.js
  <tasks> -- SLICE
    - action.js
    - reducer.js
    - actionTypes.js
  <employees> -- SLICE
    - action.js
    - reducer.js
    - actionTypes.js

* Duck Module Approach
<src>
 <store>
  - store.js
  - task.js
  - employees.js

* Implementing Duck Module Approach
src
|----store
|----|--> configureStore.js
|----|--> tasks.js
|----index.js



- tasks.js
// ActionTypes
export const ADD_TASK = "ADD_TASK";
export const REMOVE_TASK = "REMOVE_TASK";
export const COMPLETE_TASK = "COMPLETE_TASK";

// Action Creators
export const addTask = (task) => {
    return {type: ADD_TASK, payload: {task: task}}
}

export const removeTask = (id) => {
    return {type: REMOVE_TASK, payload: {id: id}}
}

export const completeTask = (id) => {
    return {type: COMPLETE_TASK, payload: {id: id}}
}

// Reducer
let id = 0;

export default function reducer(state = [], action) {
    switch (action.type) {
        case ADD_TASK:
            return [
                ...state,
                {
                    id: ++id,
                    task: action.payload.task,
                    completed: false
                }
            ]
        case REMOVE_TASK:
            return state.filter(task => task.id !== action.payload.id);

        case COMPLETE_TASK:
            return state.map(task => {
                if(task.id === action.payload.id) {
                    return {
                        ...task,
                        completed: !task.completed
                    }
                }
                return task;
            })
        default:
            return state;
    }
}

- configureStore.js
import { legacy_createStore as createStore} from 'redux';
import reducer from './++tasks';

const store = createStore(reducer)

export default store;

- index.js
import store from './store/configureStore';
import {addTask, removeTask, completeTask} from './store/tasks';

const unsubscribe = store.subscribe(() => {
    console.log("Updated", store.getState());
})

store.dispatch(addTask("Task 1"));
store.dispatch(addTask("Task 2"));

console.log(store.getState());

unsubscribe();

store.dispatch(removeTask(1));
console.log(store.getState());

store.dispatch(completeTask(2));
console.log(store.getState());


* Introduction of Redux-Thunk
-> In programming termi thunk is "a piece of code that does some delay work"
-> Rather than run the logic "now", we can write code that cna be used to perform the work later
-> Fetch API from data then store in "store"

-> Using Redux-Thunk middleware, we can write async/complex logic in Redux
-> npm i redux-thunk

- configureStore.js
import {legacy_createstore as createStore, applyMiddleware} from "redux";
import thunk from "redux-thunk";
import reducer from "store/tasks"

const store = createStore(reducer, applyMiddleware(thunk))

export default store;


* Call API using Redux-thunk
export const fetchTodo = () => async (dispatch, getState) => {
    const response = await fetch("https://jsonplaceholder.typicode.com/todos/1");
    const task = await response.json();
    dispatch(addTask(task.title));
}


- index.js
add {fetchTodo} from "......"

// unsubscribe();

console.log(store.getState());

store.dispatch(fetchTodo());

console.log(store.getState());

- Normal Redux Action
export const addTask = (task) => {
    return {type: ADD_TASK, payload: {task: task}}
}

- Action with Redux Thunk
export const fetchTodo = () => async (dispatch, getState) => {
    // Perform Asynchronous Tasks Here
    const res = await fetch.get(.....);
    const task = await res.json()
    dispatch(addTask(task.title))
}



**********************************************************************************
* What is Redux-Toolkit ?
-> Redux-Toolkit is library that simplifies redux

> npm i @reduxjs/toolkit

* Configure Store with toolkit
import { configureStore } from "@reduxjs/toolkit"
import reducer from './tasks';


const store = configureStore({reducer});


* Defining Actions - createAction
import { createAction } from "@reduxjs/toolkit"

export const ADD_TASK = "ADD_TASK";
export const REMOVE_TASK = "REMOVE_TASK";
export const COMPLETE_TASK = "COMPLETE_TASK";

// Action Creators
export const addTask = createAction("ADD_TASK")
export const removeTask = createAction("REMOVE_TASK")
export const completeTask = createAction("TASK_COMPLETED")


* Defining Reducers - createReducer
export default createReducer([], {
    [addTask.type]: (state, action) => {
        state.push({
            id: ++id,
            task: action.payload.task,
            completed: false
        })
    },
    [removeTask.type]: (state, action) => {
        return state.filter(task => task.id !== action.payload.id);
    },
    [completeTask.type]: (state, action) => {
        return state.map(task => {
            if (task.id === action.payload.id) {
                return {
                    ...task,
                    completed: !task.completed
                }
            }
            return task;
        })
    }
})

* Creating slices with Redux-toolkit - createSlice
import { createSlice } from ...

const taskSlice = createSlice({
    name: "tasks",
    initialState: [],
    reducers: {
        addTask: (state, action) => {
            state.push({
                id: ++id,
                task: action.payload.task,
                completed: false
            })
        },
        removeTask: (state, action) => {
            return state.filter(task => task.id !== action.payload.id);
        },
        completeTask: (state, action) => {
            return state.map(task => {
                if (task.id === action.payload.id) {
                    return {
                        ...task,
                        completed: !task.completed
                    }
                }
                return task;
            })
        }
    }
})

export const {addTask, removeTask, completeTask} = taskSlice.actions;
export default taskSlice.reducer;


* Exercise
- employee.js
import {createSlice} from "@reduxjs/toolkit";
let id = 0;
const employeeSlice = createSlice({
    name: 'employees',
    initialState: [],
    reducers: {
        addEmployee(state, action) {
            state.push({
                id: ++id,
                employeeName: action.payload.name
            })
        }
    }
})

export const {addEmployee} = employeeSlice.actions;

export default employeeSlice.reducer;


- configureStore.js
*import reducer from "./employee";


- index.js
store.dispatch(addEmployee({name: 'Vedat'}));
store.dispatch(addEmployee({name: 'John'}))
console.log(store.getState())


* Combining Reducers using Redux-toolkit
import employeeReducer from './employees';
import taskReducer from "./tasks"

const store = configureStore({
    reducer: {
        tasks: taskReducer,
        employees: employeeReducer
    }
})

export default store;


* Middleware in Redux 
-> Middleware is a function which run between the action and reducer

* How to create own middleware ?
- log.js
const log = store => next => action => {
    console.log(action);
    next(action);
}

export default log;

- configureStore.js
import log from "../middleware/log"


const store = createStore({
    reducer: {
        tasks: taskReducer,
        employees: employeeReducer
    },
    middleware: (getDefaultMiddleware) => [...getDefaultMiddleware(), log]
})

* Library For Logging: Redux-Logger
> npm i redux-logger

import logger from "redux-logger"

.....
    middleware: (getDefaultMiddleware) => [...getDefaultMiddleware(), logger];

action employees/addEmployee @ 15:51:32.702
prev state {tasks: Array(0), employees: Array(0)}employees: []tasks: [][[Prototype]]: Object
action     {type: 'employees/addEmployee', payload: {…}}payload: {name: 'Vedat'}name: "Vedat"[[Prototype]]: Objecttype: "employees/addEmployee"[[Prototype]]: Object
next state {tasks: Array(0), employees: Array(1)}












######################################################################################