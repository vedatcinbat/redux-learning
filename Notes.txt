-- Redux Notes --
-> Redux is a predictable state container to JavaScript apps
-> It helps you write applications that behave consistently, run in different 
environments, and are easy to test
-> Redux centralizes your application's state and logic, enabling powerful capabilities
like undo/redo, state persistence, and more

* Core Concepts of Redux
-> Single Source of Truth
--> The state of your whole application is stored in an object tree within a single store
--> This means there's only one state container (the store) for your entire application

-> State is Read-Only
--> The only way to change the state is to "emit an action", an object describing what happend
--> This ensures that no component can directly modify the state, which helps in maintainin
consistency

-> Changes are Made with Pure Functions
--> To specify how state tree is transformed by actions, you write pure reducers
--> A reducer is a pure function that takes the previous state and an action, and returns 
the next state

* Key Elements of Redux
1. Store
-> The store is the central container for the state in a Redux application. It holds the 
entire state tree of your application
-> There is only one store in a Redux application

2. Actions
-> Actions are plan Javascript objects that describe what happended in your application
-> Every action must have a "type" property that indicates the type of action being performed
-> The "type" should typically be defined as a string constant

const INCREMENT = 'INCREMENT';

const incrementAction = {
    type: INCREMENT
}

3. Reducers
-> Reducers are pure functions that take the current state and an action as arguments
and return a new state
-> They specify how to state changes in response to an action

const initialState = {value: 0};

function counterReducer(state = initialState, action) {
    switch(action.type) {
        case "INCREMENT":
            return {value: state.value + 1};
        case "DECREMENT":
            return {value: state.value - 1};
        default:
            return state;
    }
}

4. Dispatch
-> The "dispatch" function is used to send actions to the store. This is the only way to 
trigger a state change

store.dispatch(incrementAction);

5. Selectors
-> Selectors are functions that extract, derive, or compute specific pieces of data from the 
Redux state

const selectValue = state => state.value

6.Middleware
-> Middleware provides a way to extend Redux with custom functionality
-> It sits between the dispatching of an action and the moment it reaches the reducers
-> Common use cases include handling asynchronous action like API calls and logging
-> Example middleware: redux-thunk | redux-saga

When to Use Redux
Redux is particularly useful in the following scenarios:

Complex State Logic:

When the state logic is complex and involves many interactions across different parts of the application.
Predictability:

When you need predictable state management with clear rules on how state can be changed.
Debugging:

When you need powerful debugging capabilities, such as time-travel debugging, where you can go back and forth through the history of actions and state changes.
State Sharing:

When you need to share state across many components or deeply nested components.



-- Setting Up Project ------------------------------------
> npx create-react-app redux-ts-example --template typescript
> cd redux-ts-example

> npm install redux react-redux @reduxjs/toolkit

--- Project Structure ---
redux-ts-example/
├── src/
│   ├── store/
│   │   ├── actions.ts
│   │   ├── reducer.ts
│   │   ├── store.ts
│   │   ├── types.ts
│   ├── App.tsx
│   ├── Counter.tsx
│   ├── index.tsx
│   ├── react-app-env.d.ts
│   ├── setupTests.ts
│   ├── index.css
│   ├── App.css
│   ├── App.test.tsx
│   ├── logo.svg
├── package.json
├── tsconfig.json





------------------------------------------------------------------------